import { Controller, Get, Req, UseGuards, Res } from '@nestjs/common';
import { AuthService } from '../auth.service';
import { Response } from 'express';
{% if oauth.providers | selectattr('name', 'equalto', 'google') | list | length > 0 %}
import { GoogleOAuthGuard } from './google.guard';
{% endif %}
{% if oauth.providers | selectattr('name', 'equalto', 'github') | list | length > 0 %}
import { GithubOAuthGuard } from './github.guard';
{% endif %}

@Controller('auth/oauth')
export class OAuthController {
  constructor(private readonly authService: AuthService) {}

{% if oauth.providers | selectattr('name', 'equalto', 'google') | list | length > 0 %}
  @Get('google')
  @UseGuards(GoogleOAuthGuard)
  async googleAuth() {
    // Initiates the Google OAuth2 login flow
  }

  @Get('google/callback')
  @UseGuards(GoogleOAuthGuard)
  async googleAuthRedirect(@Req() req: any, @Res() res: Response) {
    try {
      const tokens = await this.authService.oauthLogin(req.user);
      
      // Validate frontend URL against whitelist
      const allowedOrigins = (process.env.ALLOWED_FRONTEND_ORIGINS || 'http://localhost:3000')
        .split(',')
        .map(origin => origin.trim());
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
      
      // Check if frontendUrl matches any allowed origin
      const isAllowed = allowedOrigins.some(origin => 
        frontendUrl === origin || frontendUrl.startsWith(origin + '/')
      );
      
      if (!isAllowed) {
        console.error(`Invalid FRONTEND_URL: ${frontendUrl}. Using safe default.`);
        const redirectUrl = `${allowedOrigins[0]}/auth/callback?token=${tokens.accessToken}`;
        return res.redirect(redirectUrl);
      }
      
      const redirectUrl = `${frontendUrl}/auth/callback?token=${tokens.accessToken}`;
      return res.redirect(redirectUrl);
    } catch (error) {
      console.error('OAuth login error:', error.message);
      const safeUrl = process.env.ALLOWED_FRONTEND_ORIGINS?.split(',')[0]?.trim() || 'http://localhost:3000';
      return res.redirect(`${safeUrl}/auth/error`);
    }
  }
{% endif %}

{% if oauth.providers | selectattr('name', 'equalto', 'github') | list | length > 0 %}
  @Get('github')
  @UseGuards(GithubOAuthGuard)
  async githubAuth() {
    // Initiates the GitHub OAuth2 login flow
  }

  @Get('github/callback')
  @UseGuards(GithubOAuthGuard)
  async githubAuthRedirect(@Req() req: any, @Res() res: Response) {
    try {
      const tokens = await this.authService.oauthLogin(req.user);
      
      // Validate frontend URL against whitelist
      const allowedOrigins = (process.env.ALLOWED_FRONTEND_ORIGINS || 'http://localhost:3000')
        .split(',')
        .map(origin => origin.trim());
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
      
      // Check if frontendUrl matches any allowed origin
      const isAllowed = allowedOrigins.some(origin => 
        frontendUrl === origin || frontendUrl.startsWith(origin + '/')
      );
      
      if (!isAllowed) {
        console.error(`Invalid FRONTEND_URL: ${frontendUrl}. Using safe default.`);
        const redirectUrl = `${allowedOrigins[0]}/auth/callback?token=${tokens.accessToken}`;
        return res.redirect(redirectUrl);
      }
      
      const redirectUrl = `${frontendUrl}/auth/callback?token=${tokens.accessToken}`;
      return res.redirect(redirectUrl);
    } catch (error) {
      console.error('OAuth login error:', error.message);
      const safeUrl = process.env.ALLOWED_FRONTEND_ORIGINS?.split(',')[0]?.trim() || 'http://localhost:3000';
      return res.redirect(`${safeUrl}/auth/error`);
    }
  }
{% endif %}
}
