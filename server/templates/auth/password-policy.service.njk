import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import { createHash } from 'crypto';

export interface PasswordPolicyConfig {
  minLength: number;
  requireUppercase: boolean;
  requireLowercase: boolean;
  requireNumbers: boolean;
  requireSpecial: boolean;
  breachCheck: boolean;
  historyCount: number; // Prevent reusing last N passwords
}

/**
 * Password Policy Service
 * 
 * Enforces enterprise password requirements:
 * - Minimum length (12+ characters recommended)
 * - Character complexity (upper, lower, numbers, special)
 * - Breach detection via HaveIBeenPwned API
 * - Password history (prevent reuse)
 * 
 * Environment Variables:
 * - PASSWORD_MIN_LENGTH: Minimum password length (default: 12)
 * - PASSWORD_BREACH_CHECK: Enable HIBP check (default: true)
 * - PASSWORD_HISTORY_COUNT: Number of old passwords to remember (default: 5)
 */
@Injectable()
export class PasswordPolicyService {
  private readonly logger = new Logger(PasswordPolicyService.name);
  private readonly config: PasswordPolicyConfig;

  constructor() {
    this.config = {
      minLength: parseInt(process.env.PASSWORD_MIN_LENGTH || '12', 10),
      requireUppercase: true,
      requireLowercase: true,
      requireNumbers: true,
      requireSpecial: process.env.PASSWORD_REQUIRE_SPECIAL !== 'false',
      breachCheck: process.env.PASSWORD_BREACH_CHECK !== 'false',
      historyCount: parseInt(process.env.PASSWORD_HISTORY_COUNT || '5', 10),
    };
  }

  /**
   * Validate password against all policy rules
   */
  async validate(password: string, options?: {
    userId?: string;
    previousHashes?: string[];
  }): Promise<{ valid: boolean; errors: string[] }> {
    const errors: string[] = [];

    // Length check
    if (password.length < this.config.minLength) {
      errors.push(`Password must be at least ${this.config.minLength} characters`);
    }

    // Complexity checks
    if (this.config.requireUppercase && !/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter');
    }
    if (this.config.requireLowercase && !/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter');
    }
    if (this.config.requireNumbers && !/[0-9]/.test(password)) {
      errors.push('Password must contain at least one number');
    }
    if (this.config.requireSpecial && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      errors.push('Password must contain at least one special character');
    }

    // Common password patterns
    const commonPatterns = [
      /^(.)\1+$/, // All same character
      /^123456/, // Sequential numbers
      /^abcdef/, // Sequential letters
      /password/i,
      /qwerty/i,
    ];
    
    for (const pattern of commonPatterns) {
      if (pattern.test(password)) {
        errors.push('Password contains a common pattern and is too weak');
        break;
      }
    }

    // Breach check (HaveIBeenPwned)
    if (this.config.breachCheck && errors.length === 0) {
      const breached = await this.checkBreach(password);
      if (breached) {
        errors.push('This password has been found in a data breach. Please choose a different password.');
      }
    }

    // History check (prevent reuse)
    if (options?.previousHashes && this.config.historyCount > 0) {
      const currentHash = this.hashPassword(password);
      const recentHashes = options.previousHashes.slice(-this.config.historyCount);
      
      if (recentHashes.some(h => this.compareHash(password, h))) {
        errors.push(`Cannot reuse one of your last ${this.config.historyCount} passwords`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Check if password exists in known data breaches
   * Uses k-Anonymity model - only sends first 5 chars of SHA-1 hash
   */
  async checkBreach(password: string): Promise<boolean> {
    try {
      // Hash the password with SHA-1
      const hash = createHash('sha1').update(password).digest('hex').toUpperCase();
      const prefix = hash.substring(0, 5);
      const suffix = hash.substring(5);

      // Query HaveIBeenPwned API
      const response = await fetch(`https://api.pwnedpasswords.com/range/${prefix}`, {
        headers: { 'User-Agent': '{{ project.name | default("FoundationWizard") }}' },
      });

      if (!response.ok) {
        this.logger.warn('HIBP API unavailable, skipping breach check');
        return false;
      }

      const text = await response.text();
      const hashes = text.split('\n');

      // Check if our hash suffix is in the response
      for (const line of hashes) {
        const [hashSuffix] = line.split(':');
        if (hashSuffix.trim() === suffix) {
          return true;
        }
      }

      return false;
    } catch (error) {
      this.logger.error(`Breach check failed: ${error.message}`);
      return false; // Fail open to not block registration
    }
  }

  /**
   * Get password strength score (0-100)
   */
  getStrength(password: string): number {
    let score = 0;

    // Length scoring (up to 40 points)
    score += Math.min(password.length * 3, 40);

    // Complexity scoring (up to 40 points)
    if (/[a-z]/.test(password)) score += 10;
    if (/[A-Z]/.test(password)) score += 10;
    if (/[0-9]/.test(password)) score += 10;
    if (/[^a-zA-Z0-9]/.test(password)) score += 10;

    // Variety scoring (up to 20 points)
    const uniqueChars = new Set(password).size;
    score += Math.min(uniqueChars * 2, 20);

    // Penalties
    if (/^(.)\1+$/.test(password)) score -= 20; // Repeated chars
    if (/^[a-zA-Z]+$/.test(password)) score -= 10; // Letters only

    return Math.max(0, Math.min(100, score));
  }

  /**
   * Get strength label
   */
  getStrengthLabel(password: string): 'weak' | 'fair' | 'good' | 'strong' {
    const score = this.getStrength(password);
    if (score < 30) return 'weak';
    if (score < 50) return 'fair';
    if (score < 70) return 'good';
    return 'strong';
  }

  // Private helpers

  private hashPassword(password: string): string {
    return createHash('sha256').update(password).digest('hex');
  }

  private compareHash(password: string, hash: string): boolean {
    return this.hashPassword(password) === hash;
  }
}
