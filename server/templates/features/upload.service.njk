import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { promises as fs } from 'fs';
import { join } from 'path';
import { createHash } from 'crypto';
{% if features.queues %}
import { DocumentProducer } from '../queue/producers/document.producer';
{% endif %}

export interface UploadedFileInfo {
  filename: string;
  originalName: string;
  mimeType: string;
  size: number;
  path: string;
  checksum: string;
}

@Injectable()
export class UploadService {
  private readonly logger = new Logger(UploadService.name);
  private readonly uploadDir: string;

  constructor(
    private readonly configService: ConfigService,
    {% if features.queues %}
    private readonly documentProducer: DocumentProducer,
    {% endif %}
  ) {
    this.uploadDir = this.configService.get<string>('UPLOAD_DIR', './uploads');
  }

  /**
   * Process uploaded file and generate metadata
   */
  async processUploadedFile(file: Express.Multer.File): Promise<UploadedFileInfo> {
    this.logger.log(`Processing uploaded file: ${file.originalname}`);

    // Calculate checksum
    const fileBuffer = await fs.readFile(file.path);
    const checksum = createHash('sha256').update(fileBuffer).digest('hex');

    const fileInfo: UploadedFileInfo = {
      filename: file.filename,
      originalName: file.originalname,
      mimeType: file.mimetype,
      size: file.size,
      path: file.path,
      checksum,
    };

    {% if features.queues %}
    // Queue background processing jobs
    try {
      // Generate thumbnails for images
      if (file.mimetype.startsWith('image/')) {
        await this.documentProducer.generateThumbnail({
          fileId: file.filename,
          filePath: file.path,
          sizes: [{ width: 150, height: 150 }, { width: 300, height: 300 }],
        });
      }

      // Perform OCR for PDFs/images
      if (file.mimetype === 'application/pdf' || file.mimetype.startsWith('image/')) {
        await this.documentProducer.performOCR({
          fileId: file.filename,
          filePath: file.path,
          language: 'eng',
        });
      }

      // Schedule cleanup for old temp files
      await this.documentProducer.cleanupDocument({
        fileId: file.filename,
        reason: 'temp_file_expiration',
      });
    } catch (error) {
      const err = error as Error;
      this.logger.error('Failed to queue document processing jobs:', err.message, err.stack);
      // Don't fail the upload if background jobs fail to queue
    }
    {% endif %}

    return fileInfo;
  }

  /**
   * Delete a file from storage
   */
  async deleteFile(filename: string): Promise<void> {
    const filePath = join(this.uploadDir, filename);
    
    try {
      await fs.unlink(filePath);
      this.logger.log(`File deleted: ${filename}`);
    } catch (error) {
      const err = error as Error;
      this.logger.error(`Failed to delete file ${filename}:`, err.message, err.stack);
      throw new Error('Failed to delete file');
    }
  }

  /**
   * Check if file exists
   */
  async fileExists(filename: string): Promise<boolean> {
    const filePath = join(this.uploadDir, filename);
    
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get file path
   */
  getFilePath(filename: string): string {
    return join(this.uploadDir, filename);
  }

  /**
   * Validate file size
   */
  validateFileSize(size: number, maxSize?: number): boolean {
    const limit = maxSize || this.configService.get<number>('MAX_FILE_SIZE', 5 * 1024 * 1024);
    return size <= limit;
  }

  /**
   * Validate file type
   */
  validateFileType(mimeType: string, allowedTypes?: string[]): boolean {
    const allowed = allowedTypes || this.configService.get<string>(
      'ALLOWED_FILE_TYPES',
      'image/jpeg,image/png,image/gif,application/pdf'
    ).split(',');

    return allowed.includes(mimeType);
  }
}
