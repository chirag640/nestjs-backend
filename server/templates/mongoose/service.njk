import { Injectable, NotFoundException } from '@nestjs/common';
import { {{ model.name }}Repository } from './{{ model.fileName }}.repository';
import { {{ model.createDtoName }} } from './dto/create-{{ model.fileName }}.dto';
import { {{ model.updateDtoName }} } from './dto/update-{{ model.fileName }}.dto';
import { {{ model.outputDtoName }} } from './dto/{{ model.fileName }}-output.dto';
import { PaginatedResponse, createPaginatedResponse } from '../../pagination.dto';
{% if model.encryptedFields and model.encryptedFields.length > 0 %}
import { EncryptionService } from '../../common/encryption.service';
{% endif %}

@Injectable()
export class {{ model.name }}Service {
  constructor(
    private readonly {{ model.nameCamel }}Repository: {{ model.name }}Repository,
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    private readonly encryptionService: EncryptionService,
    {% endif %}
  ) {}

  async create(dto: {{ model.createDtoName }}): Promise<{{ model.outputDtoName }}> {
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    // Encrypt sensitive fields before storing
    const encrypted = await this.encryptionService.encryptRecord(
      dto,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    const created = await this.{{ model.nameCamel }}Repository.create(encrypted);
    
    // Decrypt for response
    const decrypted = await this.encryptionService.decryptRecord(
      created,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    return this.mapToOutput(decrypted);
    {% else %}
    const created = await this.{{ model.nameCamel }}Repository.create(dto);
    return this.mapToOutput(created);
    {% endif %}
  }

  async findAll(page?: number, limit?: number): Promise<PaginatedResponse<{{ model.outputDtoName }}>> {
    // Pagination defaults: page 1, limit 10, max 100
    const currentPage = Math.max(1, Number(page) || 1);
    const itemsPerPage = Math.min(100, Math.max(1, Number(limit) || 10));
    const skip = (currentPage - 1) * itemsPerPage;
    
    const [items, total] = await Promise.all([
      this.{{ model.nameCamel }}Repository.findAll(skip, itemsPerPage),
      this.{{ model.nameCamel }}Repository.count(),
    ]);
    
    const data = items.map((item) => this.mapToOutput(item));
    return createPaginatedResponse(data, total, currentPage, itemsPerPage);
  }

  async findOne(id: string): Promise<{{ model.outputDtoName }}> {
    const item = await this.{{ model.nameCamel }}Repository.findById(id);
    if (!item) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    // Decrypt sensitive fields
    const decrypted = await this.encryptionService.decryptRecord(
      item,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    return this.mapToOutput(decrypted);
    {% else %}
    return this.mapToOutput(item);
    {% endif %}
  }

  async update(id: string, dto: {{ model.updateDtoName }}): Promise<{{ model.outputDtoName }}> {
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    // Encrypt sensitive fields before updating
    const encrypted = await this.encryptionService.encryptRecord(
      dto,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    const updated = await this.{{ model.nameCamel }}Repository.update(id, encrypted);
    if (!updated) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    
    // Decrypt for response
    const decrypted = await this.encryptionService.decryptRecord(
      updated,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    return this.mapToOutput(decrypted);
    {% else %}
    const updated = await this.{{ model.nameCamel }}Repository.update(id, dto);
    if (!updated) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    return this.mapToOutput(updated);
    {% endif %}
  }

  async remove(id: string): Promise<void> {
    const deleted = await this.{{ model.nameCamel }}Repository.delete(id);
    if (!deleted) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
  }

{% if relationships %}
  // Relationship service methods
{% for rel in relationships %}
{% if rel.type == 'many-to-one' and rel.sourceModel == model.name %}
  async findBy{{ rel.fieldName | capitalize }}({{ rel.fieldName }}: string): Promise<{{ model.outputDtoName }}[]> {
    const items = await this.{{ model.nameCamel }}Repository.findBy{{ rel.fieldName | capitalize }}({{ rel.fieldName }});
    return items.map((item) => this.mapToOutput(item));
  }

{% elif rel.type == 'one-to-many' and rel.sourceModel == model.name %}
  async get{{ rel.fieldName | capitalize }}(id: string): Promise<any[]> {
    const item = await this.{{ model.nameCamel }}Repository.findById(id);
    if (!item) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    // This would need the related service injected to fetch related items
    return [];
  }

{% endif %}
{% endfor %}
{% endif %}

  private mapToOutput(item: any): {{ model.outputDtoName }} {
    return {
      id: item._id?.toString() || item.id,
{% for field in model.fields %}
{% if field.name != 'password' and field.name != 'refreshToken' and field.name != 'passwordResetToken' and field.name != 'emailVerificationToken' %}
      {{ field.name }}: item.{{ field.name }},
{% endif %}
{% endfor %}
{% if model.timestamps %}
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
{% endif %}
    };
  }
}
