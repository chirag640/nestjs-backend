import { Injectable, NotFoundException{% if model.fields | selectattr('unique') | list | length > 0 %}, ConflictException{% endif %} } from '@nestjs/common';
import { {{ model.name }}Repository } from './{{ model.fileName }}.repository';
import { {{ model.createDtoName }} } from './dto/create-{{ model.fileName }}.dto';
import { {{ model.updateDtoName }} } from './dto/update-{{ model.fileName }}.dto';
import { {{ model.outputDtoName }} } from './dto/{{ model.fileName }}-output.dto';
import { PaginatedResponse, createPaginatedResponse } from '../../pagination.dto';
{% if model.encryptedFields and model.encryptedFields.length > 0 %}
import { EncryptionService } from '../../common/encryption.service';
{% endif %}
{% set hasPasswordField = false %}
{% for field in model.fields %}{% if field.name == 'password' or field.name == 'passwordHash' %}{% set hasPasswordField = true %}{% endif %}{% endfor %}
{% if hasPasswordField %}
import * as bcrypt from 'bcryptjs';
{% endif %}

@Injectable()
export class {{ model.name }}Service {
  constructor(
    private readonly {{ model.nameCamel }}Repository: {{ model.name }}Repository,
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    private readonly encryptionService: EncryptionService,
    {% endif %}
  ) {}

  async create(dto: {{ model.createDtoName }}): Promise<{{ model.outputDtoName }}> {
    {% for field in model.fields %}{% if field.unique %}
    // Enforce unique constraint for '{{ field.name }}' with a clean ConflictException
    const existing{{ field.name | capitalize }} = await this.{{ model.nameCamel }}Repository.findBy{{ field.name | capitalize }}((dto as Record<string, unknown>)['{{ field.name }}'] as {{ field.tsType }});
    if (existing{{ field.name | capitalize }}) {
      throw new ConflictException(`{{ model.name }} with {{ field.name }} '${(dto as Record<string, unknown>)['{{ field.name }}']}' already exists`);
    }
    {% endif %}{% endfor %}
    {% if hasPasswordField %}
    // Hash the plain-text password before persisting â€” NEVER store passwords in plain text
    const dtoWithHash = { ...dto } as Record<string, unknown>;
    if (typeof dtoWithHash['password'] === 'string') {
      dtoWithHash['password'] = await bcrypt.hash(dtoWithHash['password'] as string, 10);
    }
    const dtoToSave = dtoWithHash as {{ model.createDtoName }};
    {% else %}
    const dtoToSave = dto;
    {% endif %}
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    // Encrypt sensitive fields before storing
    const encrypted = await this.encryptionService.encryptRecord(
      dtoToSave,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    const created = await this.{{ model.nameCamel }}Repository.create(encrypted);
    
    // Decrypt for response
    const decrypted = await this.encryptionService.decryptRecord(
      created,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    return this.mapToOutput(decrypted);
    {% else %}
    const created = await this.{{ model.nameCamel }}Repository.create(dtoToSave);
    return this.mapToOutput(created);
    {% endif %}
  }

  async findAll(page?: number, limit?: number): Promise<PaginatedResponse<{{ model.outputDtoName }}>> {
    // Pagination defaults: page 1, limit 10, max 100
    const currentPage = Math.max(1, Number(page) || 1);
    const itemsPerPage = Math.min(100, Math.max(1, Number(limit) || 10));
    const skip = (currentPage - 1) * itemsPerPage;
    
    const [items, total] = await Promise.all([
      this.{{ model.nameCamel }}Repository.findAll(skip, itemsPerPage),
      this.{{ model.nameCamel }}Repository.count(),
    ]);
    
    const data = items.map((item) => this.mapToOutput(item));
    return createPaginatedResponse(data, total, currentPage, itemsPerPage);
  }

  async findOne(id: string): Promise<{{ model.outputDtoName }}> {
    const item = await this.{{ model.nameCamel }}Repository.findById(id);
    if (!item) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    // Decrypt sensitive fields
    const decrypted = await this.encryptionService.decryptRecord(
      item,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    return this.mapToOutput(decrypted);
    {% else %}
    return this.mapToOutput(item);
    {% endif %}
  }

  async update(id: string, dto: {{ model.updateDtoName }}): Promise<{{ model.outputDtoName }}> {
    {% if model.encryptedFields and model.encryptedFields.length > 0 %}
    // Encrypt sensitive fields before updating
    const encrypted = await this.encryptionService.encryptRecord(
      dto,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    const updated = await this.{{ model.nameCamel }}Repository.update(id, encrypted);
    if (!updated) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    
    // Decrypt for response
    const decrypted = await this.encryptionService.decryptRecord(
      updated,
      [{% for field in model.encryptedFields %}'{{ field }}'{% if not loop.last %}, {% endif %}{% endfor %}],
    );
    return this.mapToOutput(decrypted);
    {% else %}
    const updated = await this.{{ model.nameCamel }}Repository.update(id, dto);
    if (!updated) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    return this.mapToOutput(updated);
    {% endif %}
  }

  async remove(id: string): Promise<void> {
    const deleted = await this.{{ model.nameCamel }}Repository.delete(id);
    if (!deleted) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
  }

{% if relationships %}
  // Relationship service methods
{% for rel in relationships %}
{% if rel.type == 'many-to-one' and rel.sourceModel == model.name %}
  async findBy{{ rel.fieldName | capitalize }}({{ rel.fieldName }}: string): Promise<{{ model.outputDtoName }}[]> {
    const items = await this.{{ model.nameCamel }}Repository.findBy{{ rel.fieldName | capitalize }}({{ rel.fieldName }});
    return items.map((item) => this.mapToOutput(item));
  }

{% elif rel.type == 'one-to-many' and rel.sourceModel == model.name %}
  async get{{ rel.fieldName | capitalize }}(id: string): Promise<any[]> {
    const item = await this.{{ model.nameCamel }}Repository.findById(id);
    if (!item) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    // This would need the related service injected to fetch related items
    return [];
  }

{% endif %}
{% endfor %}
{% endif %}

  private mapToOutput(item: any): {{ model.outputDtoName }} {
    return {
      id: item._id?.toString() || item.id,
{% for field in model.fields %}
{% if field.name != 'password'
   and field.name != 'passwordResetToken'
   and field.name != 'emailVerificationToken'
   and field.name != 'pinHash'
   and field.name != 'verificationToken'
   and field.name != 'passwordResetExpires'
   and field.sensitive != true
   and not (field.name == 'refreshToken' and model.name == 'User') %}
      {{ field.name }}: item.{{ field.name }},
{% endif %}
{% endfor %}
{% if model.timestamps %}
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
{% endif %}
    };
  }
}
