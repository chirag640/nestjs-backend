import { Injectable, NotFoundException } from '@nestjs/common';
import { {{ model.name }}Repository } from './{{ model.fileName }}.repository';
import { {{ model.createDtoName }} } from './dto/create-{{ model.fileName }}.dto';
import { {{ model.updateDtoName }} } from './dto/update-{{ model.fileName }}.dto';
import { {{ model.outputDtoName }} } from './dto/{{ model.fileName }}-output.dto';
import { PaginatedResponse, createPaginatedResponse } from '../../pagination.dto';

@Injectable()
export class {{ model.name }}Service {
  constructor(private readonly {{ model.nameCamel }}Repository: {{ model.name }}Repository) {}

  async create(dto: {{ model.createDtoName }}): Promise<{{ model.outputDtoName }}> {
    const created = await this.{{ model.nameCamel }}Repository.create(dto);
    return this.mapToOutput(created);
  }

  async findAll(page?: number, limit?: number): Promise<PaginatedResponse<{{ model.outputDtoName }}>> {
    // Pagination defaults: page 1, limit 10, max 100
    const currentPage = Math.max(1, Number(page) || 1);
    const itemsPerPage = Math.min(100, Math.max(1, Number(limit) || 10));
    const skip = (currentPage - 1) * itemsPerPage;
    
    const [items, total] = await Promise.all([
      this.{{ model.nameCamel }}Repository.findAll(skip, itemsPerPage),
      this.{{ model.nameCamel }}Repository.count(),
    ]);
    
    const data = items.map((item) => this.mapToOutput(item));
    return createPaginatedResponse(data, total, currentPage, itemsPerPage);
  }

  async findOne(id: string): Promise<{{ model.outputDtoName }}> {
    const item = await this.{{ model.nameCamel }}Repository.findById(id);
    if (!item) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    return this.mapToOutput(item);
  }

  async update(id: string, dto: {{ model.updateDtoName }}): Promise<{{ model.outputDtoName }}> {
    const updated = await this.{{ model.nameCamel }}Repository.update(id, dto);
    if (!updated) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    return this.mapToOutput(updated);
  }

  async remove(id: string): Promise<void> {
    const deleted = await this.{{ model.nameCamel }}Repository.delete(id);
    if (!deleted) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
  }

{% if relationships %}
  // Relationship service methods
{% for rel in relationships %}
{% if rel.type == 'many-to-one' and rel.sourceModel == model.name %}
  async findBy{{ rel.fieldName | capitalize }}({{ rel.fieldName }}: string): Promise<{{ model.outputDtoName }}[]> {
    const items = await this.{{ model.nameCamel }}Repository.findBy{{ rel.fieldName | capitalize }}({{ rel.fieldName }});
    return items.map((item) => this.mapToOutput(item));
  }

{% elif rel.type == 'one-to-many' and rel.sourceModel == model.name %}
  async get{{ rel.fieldName | capitalize }}(id: string): Promise<any[]> {
    const item = await this.{{ model.nameCamel }}Repository.findById(id);
    if (!item) {
      throw new NotFoundException(`{{ model.name }} with ID ${id} not found`);
    }
    // This would need the related service injected to fetch related items
    return [];
  }

{% endif %}
{% endfor %}
{% endif %}

  private mapToOutput(item: any): {{ model.outputDtoName }} {
    return {
      id: item._id?.toString() || item.id,
{% for field in model.fields %}
{% if field.name != 'password' and field.name != 'refreshToken' and field.name != 'passwordResetToken' and field.name != 'emailVerificationToken' %}
      {{ field.name }}: item.{{ field.name }},
{% endif %}
{% endfor %}
{% if model.timestamps %}
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
{% endif %}
    };
  }
}
