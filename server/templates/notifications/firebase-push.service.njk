import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as admin from 'firebase-admin';

export interface PushNotificationPayload {
  title: string;
  body: string;
  imageUrl?: string;
  data?: Record<string, string>;
  badge?: number;
  sound?: string;
}

export interface SendResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

/**
 * Firebase Cloud Messaging (FCM) Push Notification Service
 * 
 * Sends push notifications to mobile devices (iOS, Android) and web.
 * 
 * ## Setup
 * 1. Create Firebase project at https://console.firebase.google.com
 * 2. Generate service account key (Project Settings > Service Accounts)
 * 3. Set environment variables:
 *    - FIREBASE_PROJECT_ID
 *    - FIREBASE_CLIENT_EMAIL
 *    - FIREBASE_PRIVATE_KEY
 * 
 * ## Usage
 * ```typescript
 * // Send to single device
 * await pushService.sendToDevice(deviceToken, {
 *   title: 'New Message',
 *   body: 'You have a new message!',
 *   data: { conversationId: '123' },
 * });
 * 
 * // Send to topic
 * await pushService.sendToTopic('news', {
 *   title: 'Breaking News',
 *   body: 'Check out the latest updates',
 * });
 * 
 * // Send to multiple devices
 * await pushService.sendToDevices(tokens, payload);
 * ```
 */
@Injectable()
export class FirebasePushService implements OnModuleInit {
  private readonly logger = new Logger(FirebasePushService.name);
  private readonly enabled: boolean;

  constructor(private readonly configService: ConfigService) {
    this.enabled = !!(
      configService.get('FIREBASE_PROJECT_ID') &&
      configService.get('FIREBASE_CLIENT_EMAIL') &&
      configService.get('FIREBASE_PRIVATE_KEY')
    );
  }

  onModuleInit() {
    if (!this.enabled) {
      this.logger.warn('Firebase is not configured. Push notifications are disabled.');
      return;
    }

    // Initialize Firebase Admin SDK
    if (!admin.apps.length) {
      admin.initializeApp({
        credential: admin.credential.cert({
          projectId: this.configService.get('FIREBASE_PROJECT_ID'),
          clientEmail: this.configService.get('FIREBASE_CLIENT_EMAIL'),
          privateKey: this.configService.get('FIREBASE_PRIVATE_KEY')?.replace(/\\n/g, '\n'),
        }),
      });
      this.logger.log('Firebase Admin SDK initialized');
    }
  }

  /**
   * Send push notification to a single device
   */
  async sendToDevice(token: string, payload: PushNotificationPayload): Promise<SendResult> {
    if (!this.enabled) {
      return { success: false, error: 'Firebase not configured' };
    }

    try {
      const message: admin.messaging.Message = {
        token,
        notification: {
          title: payload.title,
          body: payload.body,
          imageUrl: payload.imageUrl,
        },
        data: payload.data,
        android: {
          priority: 'high',
          notification: {
            sound: payload.sound || 'default',
            channelId: 'default',
          },
        },
        apns: {
          payload: {
            aps: {
              badge: payload.badge,
              sound: payload.sound || 'default',
            },
          },
        },
      };

      const response = await admin.messaging().send(message);
      this.logger.debug(`Push sent successfully: ${response}`);
      return { success: true, messageId: response };
    } catch (error) {
      this.logger.error(`Push failed: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  /**
   * Send push notification to multiple devices
   */
  async sendToDevices(tokens: string[], payload: PushNotificationPayload): Promise<{
    successCount: number;
    failureCount: number;
    results: SendResult[];
  }> {
    if (!this.enabled) {
      return { successCount: 0, failureCount: tokens.length, results: [] };
    }

    const results: SendResult[] = [];
    let successCount = 0;
    let failureCount = 0;

    // FCM allows max 500 tokens per batch
    const batches = this.chunkArray(tokens, 500);

    for (const batch of batches) {
      const message: admin.messaging.MulticastMessage = {
        tokens: batch,
        notification: {
          title: payload.title,
          body: payload.body,
          imageUrl: payload.imageUrl,
        },
        data: payload.data,
      };

      try {
        const response = await admin.messaging().sendEachForMulticast(message);
        successCount += response.successCount;
        failureCount += response.failureCount;

        response.responses.forEach((res, idx) => {
          results.push({
            success: res.success,
            messageId: res.messageId,
            error: res.error?.message,
          });
        });
      } catch (error) {
        failureCount += batch.length;
        batch.forEach(() => results.push({ success: false, error: error.message }));
      }
    }

    this.logger.debug(`Multicast: ${successCount} success, ${failureCount} failed`);
    return { successCount, failureCount, results };
  }

  /**
   * Send push notification to a topic
   */
  async sendToTopic(topic: string, payload: PushNotificationPayload): Promise<SendResult> {
    if (!this.enabled) {
      return { success: false, error: 'Firebase not configured' };
    }

    try {
      const message: admin.messaging.Message = {
        topic,
        notification: {
          title: payload.title,
          body: payload.body,
          imageUrl: payload.imageUrl,
        },
        data: payload.data,
      };

      const response = await admin.messaging().send(message);
      return { success: true, messageId: response };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Subscribe device to topic
   */
  async subscribeToTopic(tokens: string[], topic: string): Promise<boolean> {
    if (!this.enabled) return false;

    try {
      await admin.messaging().subscribeToTopic(tokens, topic);
      return true;
    } catch (error) {
      this.logger.error(`Subscribe to topic failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Unsubscribe device from topic
   */
  async unsubscribeFromTopic(tokens: string[], topic: string): Promise<boolean> {
    if (!this.enabled) return false;

    try {
      await admin.messaging().unsubscribeFromTopic(tokens, topic);
      return true;
    } catch (error) {
      this.logger.error(`Unsubscribe from topic failed: ${error.message}`);
      return false;
    }
  }

  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}
