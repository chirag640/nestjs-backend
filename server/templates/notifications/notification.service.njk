import { Injectable, Logger } from '@nestjs/common';
{% if notifications.channels.sms %}
import { Twilio } from 'twilio';
{% endif %}
{% if notifications.channels.push %}
import * as admin from 'firebase-admin';
{% endif %}
{% if notifications.channels.email %}
import { MailerService } from '@nestjs-modules/mailer';
{% endif %}

export interface NotificationPayload {
  userId: string;
  title: string;
  body: string;
  data?: Record<string, any>;
  channel?: 'email' | 'sms' | 'push' | 'inApp' | 'all';
  scheduledAt?: Date;
  priority?: 'high' | 'normal' | 'low';
}

export interface UserNotificationPreferences {
  email: boolean;
  sms: boolean;
  push: boolean;
  inApp: boolean;
  digestEnabled: boolean;
  digestFrequency?: 'daily' | 'weekly';
}

/**
 * Notification Service
 * 
 * Multi-channel notification delivery:
 * - Email (SendGrid/SMTP)
 * - SMS (Twilio/MSG91)
 * - Push (Firebase Cloud Messaging)
 * - In-App (Real-time via WebSocket)
 * 
 * Features:
 * - User notification preferences
 * - Scheduling
 * - Batching/Digest
 * - Templates
 */
@Injectable()
export class NotificationService {
  private readonly logger = new Logger(NotificationService.name);
{% if notifications.channels.sms %}
  private readonly twilioClient: Twilio;
{% endif %}

  constructor(
{% if notifications.channels.email %}
    private readonly mailerService: MailerService,
{% endif %}
  ) {
{% if notifications.channels.sms %}
    this.twilioClient = new Twilio(
      process.env.TWILIO_ACCOUNT_SID!,
      process.env.TWILIO_AUTH_TOKEN!,
    );
{% endif %}
{% if notifications.channels.push %}
    if (!admin.apps.length) {
      admin.initializeApp({
        credential: admin.credential.cert({
          projectId: process.env.FIREBASE_PROJECT_ID,
          privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
          clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
        }),
      });
    }
{% endif %}
  }

  /**
   * Send notification to user via preferred channels
   */
  async send(payload: NotificationPayload): Promise<void> {
    const { channel = 'inApp' } = payload;

    // TODO: Fetch user preferences from database
    // const preferences = await this.getUserPreferences(payload.userId);

    const promises: Promise<void>[] = [];

    if (channel === 'all' || channel === 'email') {
{% if notifications.channels.email %}
      promises.push(this.sendEmail(payload));
{% endif %}
    }

    if (channel === 'all' || channel === 'sms') {
{% if notifications.channels.sms %}
      promises.push(this.sendSMS(payload));
{% endif %}
    }

    if (channel === 'all' || channel === 'push') {
{% if notifications.channels.push %}
      promises.push(this.sendPush(payload));
{% endif %}
    }

    if (channel === 'all' || channel === 'inApp') {
      promises.push(this.sendInApp(payload));
    }

    await Promise.allSettled(promises);
  }

{% if notifications.channels.email %}
  /**
   * Send email notification
   */
  private async sendEmail(payload: NotificationPayload): Promise<void> {
    try {
      // TODO: Fetch user email from database
      const userEmail = 'user@example.com'; // Replace with actual lookup
      
      await this.mailerService.sendMail({
        to: userEmail,
        subject: payload.title,
        template: 'notification',
        context: {
          title: payload.title,
          body: payload.body,
          data: payload.data,
        },
      });
      
      this.logger.log(`Email sent to ${payload.userId}`);
    } catch (error) {
      this.logger.error(`Failed to send email: ${error.message}`);
    }
  }
{% endif %}

{% if notifications.channels.sms %}
  /**
   * Send SMS notification
   */
  private async sendSMS(payload: NotificationPayload): Promise<void> {
    try {
      // TODO: Fetch user phone from database
      const userPhone = '+1234567890'; // Replace with actual lookup
      
      await this.twilioClient.messages.create({
        body: `${payload.title}: ${payload.body}`,
        to: userPhone,
        from: process.env.TWILIO_PHONE_NUMBER!,
      });
      
      this.logger.log(`SMS sent to ${payload.userId}`);
    } catch (error) {
      this.logger.error(`Failed to send SMS: ${error.message}`);
    }
  }
{% endif %}

{% if notifications.channels.push %}
  /**
   * Send push notification via FCM
   */
  private async sendPush(payload: NotificationPayload): Promise<void> {
    try {
      // TODO: Fetch user FCM tokens from database
      const fcmTokens: string[] = []; // Replace with actual lookup
      
      if (!fcmTokens.length) {
        this.logger.warn(`No FCM tokens for user ${payload.userId}`);
        return;
      }

      await admin.messaging().sendEachForMulticast({
        tokens: fcmTokens,
        notification: {
          title: payload.title,
          body: payload.body,
        },
        data: payload.data as Record<string, string>,
        android: {
          priority: payload.priority === 'high' ? 'high' : 'normal',
        },
        apns: {
          payload: {
            aps: {
              sound: 'default',
            },
          },
        },
      });
      
      this.logger.log(`Push notification sent to ${payload.userId}`);
    } catch (error) {
      this.logger.error(`Failed to send push: ${error.message}`);
    }
  }
{% endif %}

  /**
   * Send in-app notification (stored + real-time)
   */
  private async sendInApp(payload: NotificationPayload): Promise<void> {
    try {
      // TODO: Store notification in database
      // await this.notificationModel.create({...});
      
      // TODO: Emit via WebSocket if realtime is enabled
      // this.realtimeService.sendToUser(payload.userId, 'notification', payload);
      
      this.logger.log(`In-app notification created for ${payload.userId}`);
    } catch (error) {
      this.logger.error(`Failed to create in-app notification: ${error.message}`);
    }
  }

  /**
   * Mark notification as read
   */
  async markAsRead(userId: string, notificationId: string): Promise<void> {
    // TODO: Update notification in database
    this.logger.log(`Notification ${notificationId} marked as read for ${userId}`);
  }

  /**
   * Get unread notification count
   */
  async getUnreadCount(userId: string): Promise<number> {
    // TODO: Query database
    return 0;
  }

  /**
   * Get user notifications
   */
  async getUserNotifications(userId: string, page = 1, limit = 20): Promise<any[]> {
    // TODO: Query database with pagination
    return [];
  }
}
