import { Injectable, Logger } from '@nestjs/common';
import { Response } from 'express';
import * as PDFDocument from 'pdfkit';
import * as ExcelJS from 'exceljs';

export interface ReportData {
  title: string;
  subtitle?: string;
  generatedAt?: Date;
  data: any[];
  columns: Array<{
    key: string;
    header: string;
    type?: 'string' | 'number' | 'date' | 'currency';
    width?: number;
  }>;
  metadata?: Record<string, any>;
}

/**
 * Report Generation Service
 * 
 * Generates reports in multiple formats:
 * - PDF (using PDFKit)
 * - Excel (using ExcelJS)
 * - CSV
 * - JSON
 * 
 * Features:
 * - Table data rendering
 * - Headers and footers
 * - Date/currency formatting
 * - Streaming for large datasets
 */
@Injectable()
export class ReportService {
  private readonly logger = new Logger(ReportService.name);

  /**
   * Generate PDF report
   */
  async generatePdf(report: ReportData, res: Response): Promise<void> {
    const doc = new PDFDocument({ margin: 50 });

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="${this.sanitizeFilename(report.title)}.pdf"`,
    );

    doc.pipe(res);

    // Title
    doc.fontSize(24).text(report.title, { align: 'center' });
    if (report.subtitle) {
      doc.fontSize(12).text(report.subtitle, { align: 'center' });
    }
    doc.moveDown();

    // Generated timestamp
    doc.fontSize(10).text(`Generated: ${(report.generatedAt || new Date()).toLocaleString()}`, {
      align: 'right',
    });
    doc.moveDown(2);

    // Table header
    const pageWidth = doc.page.width - 100;
    const colWidth = pageWidth / report.columns.length;
    let y = doc.y;

    doc.fontSize(10).fillColor('#ffffff');
    doc.rect(50, y, pageWidth, 20).fill('#333333');
    
    report.columns.forEach((col, i) => {
      doc.fillColor('#ffffff').text(col.header, 50 + i * colWidth + 5, y + 5, {
        width: colWidth - 10,
        align: 'left',
      });
    });
    
    y += 25;
    doc.fillColor('#000000');

    // Table rows
    let rowIndex = 0;
    for (const row of report.data) {
      // New page if needed
      if (y > doc.page.height - 100) {
        doc.addPage();
        y = 50;
      }

      // Alternate row colors
      if (rowIndex % 2 === 0) {
        doc.rect(50, y - 2, pageWidth, 18).fill('#f5f5f5');
      }

      doc.fillColor('#000000');
      report.columns.forEach((col, i) => {
        const value = this.formatValue(row[col.key], col.type);
        doc.text(value, 50 + i * colWidth + 5, y, {
          width: colWidth - 10,
          align: col.type === 'number' || col.type === 'currency' ? 'right' : 'left',
        });
      });

      y += 20;
      rowIndex++;
    }

    // Footer
    doc.fontSize(8).text(
      `Page 1 | Total rows: ${report.data.length}`,
      50,
      doc.page.height - 50,
      { align: 'center' },
    );

    doc.end();
    this.logger.log(`PDF report generated: ${report.title}`);
  }

  /**
   * Generate Excel report
   */
  async generateExcel(report: ReportData, res: Response): Promise<void> {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = '{{ project.name }}';
    workbook.created = new Date();

    const sheet = workbook.addWorksheet(report.title.substring(0, 31));

    // Title row
    sheet.mergeCells('A1:' + this.getColumnLetter(report.columns.length) + '1');
    const titleCell = sheet.getCell('A1');
    titleCell.value = report.title;
    titleCell.font = { bold: true, size: 16 };
    titleCell.alignment = { horizontal: 'center' };

    // Header row
    sheet.addRow([]);
    const headerRow = sheet.addRow(report.columns.map(c => c.header));
    headerRow.font = { bold: true };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF333333' },
    };
    headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };

    // Column widths
    report.columns.forEach((col, i) => {
      sheet.getColumn(i + 1).width = col.width || 15;
    });

    // Data rows
    for (const row of report.data) {
      const values = report.columns.map(col => {
        const value = row[col.key];
        if (col.type === 'date' && value) {
          return new Date(value);
        }
        return value;
      });
      sheet.addRow(values);
    }

    // Set response headers
    res.setHeader(
      'Content-Type',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    );
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="${this.sanitizeFilename(report.title)}.xlsx"`,
    );

    await workbook.xlsx.write(res);
    this.logger.log(`Excel report generated: ${report.title}`);
  }

  /**
   * Generate CSV report
   */
  async generateCsv(report: ReportData, res: Response): Promise<void> {
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="${this.sanitizeFilename(report.title)}.csv"`,
    );

    // Header row
    const header = report.columns.map(c => `"${c.header}"`).join(',');
    res.write(header + '\n');

    // Data rows
    for (const row of report.data) {
      const values = report.columns.map(col => {
        const value = this.formatValue(row[col.key], col.type);
        return `"${value.replace(/"/g, '""')}"`;
      });
      res.write(values.join(',') + '\n');
    }

    res.end();
    this.logger.log(`CSV report generated: ${report.title}`);
  }

  /**
   * Generate JSON report
   */
  async generateJson(report: ReportData, res: Response): Promise<void> {
    res.setHeader('Content-Type', 'application/json');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="${this.sanitizeFilename(report.title)}.json"`,
    );

    const output = {
      title: report.title,
      generatedAt: report.generatedAt || new Date(),
      totalRows: report.data.length,
      columns: report.columns.map(c => c.key),
      data: report.data,
    };

    res.send(JSON.stringify(output, null, 2));
    this.logger.log(`JSON report generated: ${report.title}`);
  }

  // Helper methods

  private formatValue(value: any, type?: string): string {
    if (value === null || value === undefined) return '';
    
    switch (type) {
      case 'date':
        return new Date(value).toLocaleDateString();
      case 'currency':
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
        }).format(value);
      case 'number':
        return new Intl.NumberFormat().format(value);
      default:
        return String(value);
    }
  }

  private sanitizeFilename(name: string): string {
    return name.replace(/[^a-z0-9]/gi, '_').substring(0, 50);
  }

  private getColumnLetter(index: number): string {
    let letter = '';
    while (index > 0) {
      const mod = (index - 1) % 26;
      letter = String.fromCharCode(65 + mod) + letter;
      index = Math.floor((index - mod) / 26);
    }
    return letter;
  }
}
